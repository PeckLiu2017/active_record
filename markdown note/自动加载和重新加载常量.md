# 自动加载和重新加载常量

### 常量的作用：

在多数编程语言中，常量不是那么重要，但在 Ruby 中[常量刷新程序]，同时也用来定义或者访问命名空间，类和模块。

###常量的储存位置：

写好程序后，常量被存储在类和模块的常量表中，你可以将其理解为哈希表。通过对这些常量的加载或重新加载来获得对代码的操作。

### 常量为何有不同加载方式：

在不同的环境中，有不同的加载方法。在开发环境中使用 `Kernel#load`，而在生产环境使用 `Kernel#require`（只加载一次）。因为需求不同，ruby和rails对于常量的解析也不一样等原因，加载方式分多钟情况。

### 常量的使用场景：

常量在嵌套之中使用普遍，嵌套是解释器维护的一个内部堆栈，它显示出一种用常量表示的路径关系，或者一种常量的[组织使用方式]。根据一定的规则维护修改。

用`Module.nesting.inspect`可以查看嵌套层次：

```
module XML
   class SAXParser
      puts Module.nesting.inspect
   end
end
[XML::SAXParser, XML] # 这里是两个嵌套。
```

`Billing::Invoice` 由两个常量组成，其中 `Billing` 是相对常量，相对常量的解析算法是：

在代码中的特定位置，假如使用 cref 表示嵌套中的第一个元素，如果没有嵌套，则表示 `Object`。

简单来说，相对常量（relative constant）引用的解析算法如下：

1. 如果嵌套不为空，在嵌套中按元素顺序查找常量。元素的祖先忽略不计。
2. 如果未找到，算法向上，进入 cref 的祖先链。
3. 如果未找到，而且 cref 是个模块，在 `Object` 中查找常量。
4. 如果未找到，在 cref 上调用 `const_missing` 方法。这个方法的默认行为是抛出 `NameError`异常，不过可以覆盖。

Rails 的自动加载机制没有仿照这个算法，查找的起点是要自动加载的常量名称，即 cref。

### 相对常量和绝对常量：

> 在开头加上两个冒号可以把第一部分的相对常量变成绝对常量，例如 `::Billing::Invoice`。此时，`Billing` 作为顶层常量查找。







初始化脚本只在程序初始化的时候加载一次，所以